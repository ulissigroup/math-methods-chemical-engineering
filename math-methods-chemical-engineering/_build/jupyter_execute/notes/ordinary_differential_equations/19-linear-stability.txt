from scipy.integrate import solve_ivp
import numpy as np
import matplotlib.pyplot as plt

alpha = 1 # 1/day
beta = 0.2 #1/wolves/day
delta = 0.5 #1/rabbits/day
gamma = 0.2 #1/day

def diff_eq(t,population): 
  # t is independent variable
  # y is a vector of things we want solve_ivp to integrate for
  #  y = [y1, y2]
  #  y = [x,y]
  # return vector the same shape as population/y
    # this will be the differential equation for each thing in population/y

  x,y = population

  return [alpha*x - beta*x*y,
          delta*x*y - gamma*y]


t_span = [0, 100]
initial_population = [0.5, 5.1]
t_eval = np.linspace(0,100, 500)

#Solve the differential equation
sol = solve_ivp(diff_eq, 
                t_span, 
                initial_population, 
                t_eval=t_eval)

#Plot the solution vs time
plt.plot(sol.t, sol.y.T)
plt.xlabel('Time [days]')
plt.ylabel('Population')
plt.legend(['Rabbits','Wolves'])
plt.show()

# Plot the phase portrait and grid
plt.plot(sol.y[0,:], sol.y[1,:])
plt.plot(sol.y[0,0:1], sol.y[1,0:1],'or')
plt.xlabel('Population of Rabbits')
plt.ylabel('Population of Wolves')

#Plot the phase portrait grid

r = np.linspace(0, 1.5, 20) # rabbit grid
f = np.linspace(0, 10, 20) # wolves grid

R, F = np.meshgrid(r, f) # 2D arrays of (rabbit, wolves) points

DR, DF = diff_eq(0, [R, F])

# This normalizes the arrows so they are all the same length and just show the direction
N = np.sqrt(DR**2 + DF**2)
N[N==0] = 1 # eliminate / 0 errors, it is sort of optional.
DR /= N
DF /= N

plt.quiver(R, F, DR, DF)



from scipy.integrate import solve_ivp
import numpy as np
import matplotlib.pyplot as plt

alpha = 1 # 1/day
beta = 0.2 #1/wolves/day
delta = 0.5 #1/rabbits/day
gamma = 0.2 #1/day

def diff_eq(t,population): 
  # t is independent variable
  # y is a vector of things we want solve_ivp to integrate for
  #  y = [y1, y2]
  #  y = [x,y]
  # return vector the same shape as population/y
    # this will be the differential equation for each thing in population/y

  x,y = population

  return [alpha*x - beta*x*y,
          delta*x*y - gamma*y]


t_span = [0, 100]
initial_population = [0.4, 5]
t_eval = np.linspace(0,100, 500)

#Solve the differential equation
sol = solve_ivp(diff_eq, 
                t_span, 
                initial_population, 
                t_eval=t_eval)

#Plot the solution vs time
plt.plot(sol.t, sol.y.T)
plt.xlabel('Time [days]')
plt.ylabel('Population')
plt.legend(['Rabbits','Wolves'])
plt.show()

# Plot the phase portrait and grid
plt.plot(sol.y[0,:], sol.y[1,:])
plt.plot(sol.y[0,0:1], sol.y[1,0:1],'or')
plt.xlabel('Population of Rabbits')
plt.ylabel('Population of Wolves')

#Plot the phase portrait grid

r = np.linspace(0, 1.5, 20) # rabbit grid
f = np.linspace(0, 10, 20) # wolves grid

R, F = np.meshgrid(r, f) # 2D arrays of (rabbit, wolves) points

DR, DF = diff_eq(0, [R, F])

# This normalizes the arrows so they are all the same length and just show the direction
N = np.sqrt(DR**2 + DF**2)
N[N==0] = 1 # eliminate / 0 errors, it is sort of optional.
DR /= N
DF /= N

plt.quiver(R, F, DR, DF)



from scipy.integrate import solve_ivp
import numpy as np
import matplotlib.pyplot as plt

alpha = 1 # 1/day
beta = 0.2 #1/wolves/day
delta = 0.5 #1/rabbits/day
gamma = 0.2 #1/day

def diff_eq(t,population): 
  # t is independent variable
  # y is a vector of things we want solve_ivp to integrate for
  #  y = [y1, y2]
  #  y = [x,y]
  # return vector the same shape as population/y
    # this will be the differential equation for each thing in population/y

  x,y = population

  return [alpha*x - beta*x*y,
          delta*x*y - gamma*y]


t_span = [0, 100]
initial_population = [0, 0]
t_eval = np.linspace(0,100, 500)

#Solve the differential equation
sol = solve_ivp(diff_eq, 
                t_span, 
                initial_population, 
                t_eval=t_eval)

#Plot the solution vs time
plt.plot(sol.t, sol.y.T)
plt.xlabel('Time [days]')
plt.ylabel('Population')
plt.legend(['Rabbits','Wolves'])
plt.show()

# Plot the phase portrait and grid
plt.plot(sol.y[0,:], sol.y[1,:])
plt.plot(sol.y[0,0:1], sol.y[1,0:1],'or')
plt.xlabel('Population of Rabbits')
plt.ylabel('Population of Wolves')

#Plot the phase portrait grid

r = np.linspace(0, 1.5, 20) # rabbit grid
f = np.linspace(0, 10, 20) # wolves grid

R, F = np.meshgrid(r, f) # 2D arrays of (rabbit, wolves) points

DR, DF = diff_eq(0, [R, F])

# This normalizes the arrows so they are all the same length and just show the direction
N = np.sqrt(DR**2 + DF**2)
N[N==0] = 1 # eliminate / 0 errors, it is sort of optional.
DR /= N
DF /= N

plt.quiver(R, F, DR, DF)



from scipy.integrate import solve_ivp
import numpy as np
import matplotlib.pyplot as plt

alpha = 1 # 1/day
beta = 0.2 #1/wolves/day
delta = 0.5 #1/rabbits/day
gamma = 0.2 #1/day

def diff_eq(t,population): 
  # t is independent variable
  # y is a vector of things we want solve_ivp to integrate for
  #  y = [y1, y2]
  #  y = [x,y]
  # return vector the same shape as population/y
    # this will be the differential equation for each thing in population/y

  x,y = population

  return [alpha*x - beta*x*y,
          delta*x*y - gamma*y]


t_span = [0, 150]
initial_population = [0.01, 0.01]
t_eval = np.linspace(0,150, 500)

#Solve the differential equation
sol = solve_ivp(diff_eq, 
                t_span, 
                initial_population, 
                t_eval=t_eval,
                rtol=1e-10,
                atol=1e-12)

#Plot the solution vs time
plt.plot(sol.t, sol.y.T[:,1])
plt.xlabel('Time [days]')
plt.ylabel('Population')
plt.legend(['Rabbits','Wolves'])
plt.show()

# Plot the phase portrait and grid
plt.plot(sol.y[0,:], sol.y[1,:])
plt.plot(sol.y[0,0:1], sol.y[1,0:1],'or')
plt.xlabel('Population of Rabbits')
plt.ylabel('Population of Wolves')

#Plot the phase portrait grid

r = np.linspace(0, 1.5, 20) # rabbit grid
f = np.linspace(0, 10, 20) # wolves grid

R, F = np.meshgrid(r, f) # 2D arrays of (rabbit, wolves) points

DR, DF = diff_eq(0, [R, F])

# This normalizes the arrows so they are all the same length and just show the direction
N = np.sqrt(DR**2 + DF**2)
N[N==0] = 1 # eliminate / 0 errors, it is sort of optional.
DR /= N
DF /= N

plt.quiver(R, F, DR, DF)







# We need this to work like fun(x)=0

def diff_eq(t,population): 
  # t is independent variable
  # y is a vector of things we want solve_ivp to integrate for
  #  y = [y1, y2]
  #  y = [x,y]
  # return vector the same shape as population/y
    # this will be the differential equation for each thing in population/y

  x,y = population

  return [alpha*x - beta*x*y,
          delta*x*y - gamma*y]



def myfun(x):
  return 2*x

print(myfun(1))

myfun = lambda x: 2*x # is shorthand for def myfun(x): return x
print(myfun(1))

new_diff_eq = lambda x: diff_eq(0,x)

# # example with two inputs
# def myfun(x, y):
#   return 2*x

# myfun = lambda x,y: 2*x # is shorthand for def myfun(x): return x

# print(myfun(1, 2))


from scipy.optimize import fsolve

def diff_eq(t, population): 
  # t is independent variable
  # y is a vector of things we want solve_ivp to integrate for
  #  y = [y1, y2]
  #  y = [x,y]
  # return vector the same shape as population/y
    # this will be the differential equation for each thing in population/y

  x,y = population

  return [alpha*x - beta*x*y,
          delta*x*y - gamma*y]

solution = fsolve(diff_eq,
     [0.5, 0.5])

solution

import numpy as np
A = [[3,2],
     [-6,1]]

eigval, eigvec = np.linalg.eig(A)
print(eigval)

import numpy as np
A = [[-2,-3],
     [4,1]]

eigval, eigvec = np.linalg.eig(A)
print(eigval)

from scipy.integrate import solve_ivp
import numpy as np
import matplotlib.pyplot as plt


def diff_eq(t,y): 
  y1, y2 = y

  return [y1*y2-y2-6*y1,
          -y1**2+y2]


t_span = [0, 10]
y0 = [3,9]
t_eval = np.linspace(0,10, 100)

#Solve the differential equation
sol = solve_ivp(diff_eq, 
                t_span, 
                y0, 
                t_eval=t_eval)

#Plot the solution vs time
plt.plot(sol.t, sol.y.T)
plt.xlabel('t')
plt.legend(['y_1','y_2'])
plt.show()

# Plot the phase portrait
plt.plot(sol.y[0,:], sol.y[1,:])
plt.plot(sol.y[0,0:1], sol.y[1,0:1],'or')
plt.xlabel('y_1')
plt.ylabel('y_2')

#Plot the phase portrait grid
r = np.linspace(-7, 10, 20) # y1 grid
f = np.linspace(-7, 20, 20) # y2 grid

R, F = np.meshgrid(r, f) # 2D arrays of (rabbit, wolves) points

DR, DF = diff_eq(0, [R, F])

# This normalizes the arrows so they are all the same length and just show the direction
N = np.sqrt(DR**2 + DF**2)
N[N==0] = 1 # eliminate / 0 errors, it is sort of optional.
DR /= N
DF /= N

plt.quiver(R, F, DR, DF)



J = [[0,-0.08],
     [2.5,0]]

np.linalg.eig(J)

from scipy.optimize import root

alpha = 1 # 1/day
beta = 0.2 #1/wolves/day
delta = 0.5 #1/rabbits/day
gamma = 0.2 #1/day

def diff_eq(t,population): 
  # t is independent variable
  # y is a vector of things we want solve_ivp to integrate for
  #  y = [y1, y2]
  #  y = [x,y]
  # return vector the same shape as population/y
    # this will be the differential equation for each thing in population/y

  x,y = population

  return np.array([alpha*x - beta*x*y,
          delta*x*y - gamma*y])

# find a steady state starting from [2, 5]
steady_state = fsolve(lambda x: diff_eq(0, x),
                        [2,5])
print('I guessed %s, and found a steady state %s' % ([2,5],steady_state))


! pip install numdifftools
import numdifftools as nd

jac_fun = nd.Jacobian(lambda x: diff_eq(0, x))
jac = jac_fun(steady_state)
np.linalg.eig(jac)

jac


