import numpy as np

#Define A and the inverse of A
A = np.array([[2,-6],[4,-2]])
Ainv = np.array([[-1/10,3/10],[-1/5,1/10]])

#Note that this looks very good, but some residual rounding errors in the 
# computation has one element VERY close to zero but not quite right. For 
# practical purposes, anything less than about 10^-8 is probably the same 
# thing as zero in numerical methods
print(A@Ainv)

#Check Ainv*A
print(Ainv@A)


A = np.array([[-3,1,-1],[1,0,1],[-2,2,2]])
print(A)

# We can use np.linalg.matrix_rank(A)
print('The rank of A is %d'%np.linalg.matrix_rank(A))

A = np.array([[-3,1,-1],[1,0,1],[-2,2,3]])

# Calculate the matrix rank of A
print('The rank of A is %d'%np.linalg.matrix_rank(A))

A = np.array([[2,-6],[4,-2]])

#Same as the answer we got above!
print(np.linalg.inv(A))

#Try to get the inverse of a singular matrix
A = np.array([[-3,1,-1],[1,0,1],[-2,2,2]])

#Same as the answer we got above!
Ainv = np.linalg.inv(A) 
print(Ainv)

#Check; notice that Ainv*A is not the identity! This is a problem with numerical
# methods; we have to be on top of our game all the time!
Ainv@A

import sympy as sp

# Example from earlier in lecture
A = [[-3, 1, -1],
[1,0,1],
[-2,2,2]]

# Make a sympy matrix
m = sp.Matrix(A)
m_rref, pivots = m.rref() # Compute reduced row echelon form 

#notice the pretty latex printing!
m_rref

A = np.array([[1,-1,0],
              [1,-3,2],
              [0,1,-2]])
b = np.array([10,0,0])

#Same answer as above!
print(np.linalg.solve(A,b))


A = np.array([[1,2,1],
              [2,-1,1],
              [4,3,3],
              [3,1,2]])
b = np.array([1,2,4,3])


#Same answer!
print(np.linalg.solve(A,b))


#Try least squares solution to this problem
x, res, rank, s = np.linalg.lstsq(A,b)

#First, print the rank of the matrix:
print(rank)

#print the solution
print(x)

# print the residual
print(res)

#Check that this is a solution
print(A@x)

A@np.array([1,0,0])


